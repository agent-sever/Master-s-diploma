
open_system('pathPlanning.slx')
% --- Завантаження карти ---
load exampleMaps.mat simpleMap
assignin('base', 'simpleMap', simpleMap);

% --- Спільна ціль ---
goalLoc = [5 5];
assignin('base', 'goalLoc', goalLoc);

% --- Агент 1 ---
startLoc = [9 9];  % старт
assignin('base', 'startLoc', startLoc);
simData1 = sim('pathPlanning.slx');

% --- Агент 2 ---
startLoc = [20 20];
assignin('base', 'startLoc', startLoc);
simData2 = sim('pathPlanning.slx');

% --- Початковий заряд батареї ---
battery1 = 100;  
battery2 = 100;  
assignin('base', 'battery1', battery1);
assignin('base', 'battery2', battery2);

% --- Візуалізація карти ---
map = binaryOccupancyMap(simpleMap);
figure;
show(map)
hold on

plot(goalLoc(1), goalLoc(2), 'rx', 'MarkerSize', 8, 'LineWidth', 2)
text(goalLoc(1)+0.5, goalLoc(2), 'Dock')

plot(9, 9, 'go', 'MarkerSize', 8, 'LineWidth', 2)
text(9+0.5, 9, 'Start 1')
plot(20, 20, 'go', 'MarkerSize', 8, 'LineWidth', 2)
text(20+0.5, 20, 'Start 2')

pose1 = simData1.Pose;
plot(pose1(:,1), pose1(:,2), '-b', 'LineWidth', 1.5)
pose2 = simData2.Pose;
plot(pose2(:,1), pose2(:,2), '-r', 'LineWidth', 1.5)

lgd = legend('Dock', 'Start 1', 'Start 2', 'Agent 1', 'Agent 2', 'Map');
title('')
lgd.Position = [0.84 0.77 0.15 0.1];

grid on;

% --- Отримуємо межі графіка ---
ax = gca;
fig = gcf;
xLimits = xlim;
yLimits = ylim;

% Приховуємо звичайні осі
% set(ax, 'XColor', 'none', 'YColor', 'none');
% Залишаємо осі видимими
set(ax, 'XColor', 'k', 'YColor', 'k'); % чорні осі

% Прибираємо стандартні підписи осей
xlabel(''); 
ylabel('');

% --- Відступ для осей від країв графіка ---
xOffset = -2.5;  % для Y-осі
yOffset = 0.0;  % для X-осі

% --- Стрілка осі X ---
[x1_fig, y1_fig] = ds2nfu(ax, xLimits(1)+2.5, yLimits(1)-yOffset);
[x2_fig, y2_fig] = ds2nfu(ax, xLimits(2)+2.5, yLimits(1)-yOffset);
annotation(fig,'arrow', [x1_fig x2_fig], [y1_fig y2_fig], 'LineWidth', 1.5);

% --- Стрілка осі Y ---
[x3_fig, y3_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(1));
[x4_fig, y4_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(2)+2);
annotation(fig,'arrow', [x3_fig x4_fig], [y3_fig y4_fig], 'LineWidth', 1.5);

% --- Підпис осі X (трохи правіше) ---
text(mean([xLimits(1) xLimits(2)]) + 17, yLimits(1)-yOffset-1, 'X, м', ...
    'FontSize', 14, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top');

% --- Підпис осі Y (вище) ---
text(xLimits(1)-xOffset-3, yLimits(2) + 2, 'Y, м', ...
    'FontSize', 14, 'HorizontalAlignment', 'right', 'VerticalAlignment', 'bottom', ...
    'Rotation', 0);

hold off




>>%Центр
% Центр: виправлений скрипт з реалістичним рухом і моделлю батареї

clearvars -except simData1 simData2 simpleMap goalLoc
close all

%% --- Параметри витрати енергії (після clearvars!) ---
a = 0.5;      % постійна частина %/с (електроніка)
b = 0.8;      % лінійний коефіцієнт від v
c = 3;      % квадратичний коефіцієнт (аеродинаміка)

idle_rate = 0.05;  % %/с під час очікування у зоні
stop_rate = 0.01; % %/с при повній стоянці/вимкненні

dt = 1; % одна ітерація циклу = 1 сек
batteryDrainPerSec_move = @(v) max(0, a + b.*v + c.*v.^2); % функція від v
k=0.6;
% Масиви для збереження історії (для графіків)
maxSimTime = 10000;
battery1Array = nan(maxSimTime,1);
battery2Array = nan(maxSimTime,1);
timeArray     = nan(maxSimTime,1);
speed1Array   = nan(maxSimTime,1);
speed2Array   = nan(maxSimTime,1);

%% --- Ініціалізація фігури і карти ---
figure('Name','Координація групи дронів');
map = binaryOccupancyMap(simpleMap);
show(map)
title('')
grid on;

% --- Отримуємо межі графіка ---
ax = gca;
fig = gcf;
xLimits = xlim;
yLimits = ylim;
% Залишаємо осі видимими
set(ax, 'XColor', 'k', 'YColor', 'k'); % чорні осі

% Прибираємо стандартні підписи осей
xlabel(''); 
ylabel('');


% --- Відступ для осей від країв графіка ---
xOffset = -1.5;  % для Y-осі
yOffset = -1.4;  % для X-осі

% --- Стрілка осі X ---
[x1_fig, y1_fig] = ds2nfu(ax, xLimits(1)+1.5, yLimits(1)-yOffset);
[x2_fig, y2_fig] = ds2nfu(ax, xLimits(2)+1.5, yLimits(1)-yOffset);
annotation(fig,'arrow', [x1_fig x2_fig], [y1_fig y2_fig], 'LineWidth', 1.5);

% --- Стрілка осі Y ---
[x3_fig, y3_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(1)+1.5);
[x4_fig, y4_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(2)+1.5);
annotation(fig,'arrow', [x3_fig x4_fig], [y3_fig y4_fig], 'LineWidth', 1.5);

% --- Підпис осі X (трохи правіше) ---
text(mean([xLimits(1) xLimits(2)]) + 18, yLimits(1)-yOffset-2, 'X, м', ...
    'FontSize', 14, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top');

% --- Підпис осі Y (вище) ---
text(xLimits(1)-xOffset-3, yLimits(2) + 2.4, 'Y, м', ...
    'FontSize', 14, 'HorizontalAlignment', 'right', 'VerticalAlignment', 'bottom', ...
    'Rotation', 0);

hold on
%% view([-35 25]);
 view(2);
axis vis3d; axis equal; grid on;
camlight('headlight'); lighting gouraud; material shiny;

start1 = [9,9]; start2 = [20,20];
plot(start1(1), start1(2), 'go', 'MarkerSize',8,'LineWidth',2)
plot(start2(1), start2(2), 'go', 'MarkerSize',8,'LineWidth',2)
plot(goalLoc(1), goalLoc(2), 'rx', 'MarkerSize',8,'LineWidth',2)
text(start1(1)+0.5,start1(2),'Start 1')
text(start2(1)+0.5,start2(2),'Start 2')
text(goalLoc(1)+0.5,goalLoc(2),'Dock')

zoneHalf = 2.5;
rectangle('Position',[goalLoc(1)-zoneHalf, goalLoc(2)-zoneHalf, 2*zoneHalf, 2*zoneHalf],...
    'EdgeColor','m','LineStyle','--','LineWidth',1.2)
light('Position',[10 10 10],'Style','infinite'); lighting gouraud; material shiny

% --- Параметри часу/логіки ---
framesPerSec = 10;    % крок у кадрах (у тебе 10 кадрів = 1 сек)
decisionWindow = 50;  % 5сек


% --- Траєкторії з Simulink (очікується, що simData1/2 існують) ---
pose1 = simData1.Pose; % Nx3: [x y yaw]
pose2 = simData2.Pose;
nFrames1 = size(pose1,1);
nFrames2 = size(pose2,1);

% індекси кадрів
idx1 = 1;
idx2 = 1;

% час
timeSec = 0;

% стани
agent1_in_zone = false; agent2_in_zone = false;
agent1_waiting = false; agent2_waiting = false;
agent1_allowed = true; agent2_allowed = true;
agent1_released = false; agent2_released = false;
agent1_done = false; agent2_done = false;

agent1_arrival_time = inf; agent2_arrival_time = inf;
agent1_release_time = inf; agent2_release_time = inf;
agent1_zone_time = -inf; agent2_zone_time = -inf;

% батареї
battery1 = 100; battery2 = 100;

% попередні позиції для виміру швидкості
prevPos1 = pose1(1,1:2);
prevPos2 = pose2(1,1:2);

% графічні об'єкти
hTrail1 = plot(pose1(1,1), pose1(1,2), '-b', 'LineWidth', 1.5);
hTrail2 = plot(pose2(1,1), pose2(1,2), '-r', 'LineWidth', 1.5);
hText1 = text(0,0,'','FontSize',9,'Color','k');
hText2 = text(0,0,'','FontSize',9,'Color','k');

% підготовка STL (як було у тебе)
hasSTL = true;
try fv = stlread('groundvehicle.stl'); catch; fv = []; hasSTL=false; end
% ----------------------------
% Обробка STL (читання → нормалізація → fallback)
% ----------------------------
% Вхід: fv (може бути struct або cell або порожній)
V = []; F = [];
if hasSTL && ~isempty(fv)
    if isstruct(fv)
        % Різні формати: vertices/faces або Vertices/Faces
        if isfield(fv,'vertices') && isfield(fv,'faces')
            V = double(fv.vertices);
            F = double(fv.faces);
        elseif isfield(fv,'Vertices') && isfield(fv,'Faces')
            V = double(fv.Vertices);
            F = double(fv.Faces);
        else
            % Пошук числових масивів у полях структури
            fld = fieldnames(fv);
            for i=1:numel(fld)
                val = fv.(fld{i});
                if isnumeric(val) && size(val,2)==3 && isempty(V)
                    V = double(val);
                elseif isnumeric(val) && (size(val,2)==3 || size(val,2)==4) && isempty(F)
                    F = double(val);
                end
            end
        end
    elseif iscell(fv) && numel(fv) >= 2
        % stlread може повернути {F,V} або {V,F} залежно від реалізації
        % Спробуємо угадати: якщо перший має 3 колонки — приймаємо як V
        try
            A = double(fv{1});
            B = double(fv{2});
            if size(A,2)==3 && size(B,2)>=3
                V = A; F = B;
            elseif size(B,2)==3 && size(A,2)>=3
                V = B; F = A;
            else
                V = []; F = [];
            end
        catch
            V = []; F = [];
        end
    elseif isnumeric(fv) && size(fv,2)==3
        % Рідкісний випадок — один масив вершин
        V = double(fv);
        F = [];
    end
end

% Нормалізація індексів (0-based → 1-based), триангуляція, перевірки
if ~isempty(F)
    F = double(F);
    if any(F(:)==0)
        F = F + 1;
    end
    if size(F,2) == 4
        Q = F;
        F = zeros(size(Q,1)*2,3);
        t = 1;
        for i=1:size(Q,1)
            a=Q(i,1); b=Q(i,2); c=Q(i,3); d=Q(i,4);
            F(t,:) = [a b c]; t=t+1;
            F(t,:) = [a c d]; t=t+1;
        end
    end
    if iscell(F)
        try F = cell2mat(F); catch; end
    end
end

% Якщо не вдалося прочитати STL — застосувати fallback box-модель
if isempty(V) || isempty(F)
    warning('Не вдалося прочитати groundvehicle.stl — застосовано fallback box-модель.');
    w = 0.7; l = 1.2; h = 0.4;
    V = [ -l/2 -w/2 0;
           -l/2  w/2 0;
            l/2  w/2 0;
            l/2 -w/2 0;
           -l/2 -w/2 h;
           -l/2  w/2 h;
            l/2  w/2 h;
            l/2 -w/2 h];
    F = [1 2 3; 1 3 4; 5 6 7; 5 7 8; 1 2 6; 1 6 5; 2 3 7; 2 7 6; 3 4 8; 3 8 7; 4 1 5; 4 5 8];
end

% Центруємо і масштабуємо модель
V = double(V);
V = V - mean(V,1);
scaleSTL = 0.6; % підлаштуй якщо треба
V = V * scaleSTL;

% Якщо вершини лежать на нулі Z — піднімаємо трохи, щоб не "вкопувалось"
zMin = min(V(:,3));
if abs(zMin) < 1e-6
    V = V + repmat([0 0 0.02], size(V,1),1);
end

% Створюємо patch-и для двох агентів (один раз)
agent1_patch = patch('Faces',F,'Vertices',V,'FaceColor',[0 0.2 0.8], ...
    'EdgeColor','none','FaceLighting','gouraud','FaceAlpha',1);
agent2_patch = patch('Faces',F,'Vertices',V,'FaceColor',[0.8 0.1 0.1], ...
    'EdgeColor','none','FaceLighting','gouraud','FaceAlpha',1);


% Для стислості припустимо відтворено блок, який встановлює V,F та agent_patch
% (копіюй сюди свій код обробки stl: нормалізація F/V, fallback box, scaleSTL тощо)
% Після цього створюємо agent1_patch та agent2_patch (як у твоєму коді).

% ------------------------------
% ГОЛОВНИЙ ЦИКЛ
% ------------------------------
while ~(agent1_done && agent2_done) && timeSec < maxSimTime
    timeSec = timeSec + 1;
    
    % ----------------- AGENT 1 -----------------
    % Оновлення індексу (якщо дозволено)
    if agent1_allowed && idx1 < nFrames1
        % крок вперед: рухаємося на framesPerSec кадрів (щоб відповідати твоєму timestep)
        idx1 = min(nFrames1, idx1 + framesPerSec);
    end
    
    % Поточна позиція
    cur1 = pose1(idx1, :);
    % швидкість (реалістична: зміна позиції між ітераціями)
    dist1 = norm(cur1(1:2) - prevPos1);
    v1 = dist1 / dt;
    prevPos1 = cur1(1:2);
    
    % Обчислення витрати
    if agent1_allowed
        drain1 = batteryDrainPerSec_move(v1);
        battery1 = max(0, battery1 - drain1*dt);
    elseif agent1_waiting
        battery1 = max(0, battery1 - idle_rate*dt);
    else
        battery1 = max(0, battery1 - stop_rate*dt);
    end
    
    % Оновлення графіки для агента 1
    set(hTrail1, 'XData', pose1(1:idx1,1), 'YData', pose1(1:idx1,2));
    set(hText1, 'Position', [cur1(1)+0.3, cur1(2)], 'String', sprintf('A1 %.0f%%', battery1));
    % оновлення patch'а (як у тебе)
    theta1 = cur1(3);
    Rz1 = [cos(theta1) -sin(theta1) 0; sin(theta1) cos(theta1) 0; 0 0 1];
    newV1 = (Rz1 * (V)')' + repmat([cur1(1) cur1(2) 0], size(V,1), 1);
    set(agent1_patch, 'Vertices', newV1);
    
    % В'їзд у зону
    if ~agent1_in_zone && norm(cur1(1:2) - goalLoc) <= zoneHalf
        agent1_in_zone = true;
        agent1_waiting = true;
        agent1_allowed = false;
        agent1_zone_time = timeSec;
        fprintf('[%2ds] ○ Агент 1 увійшов у зону. Запит на координацію надіслано.\n', timeSec);
    end
    if idx1 >= nFrames1 && ~agent1_done
        agent1_done = true;
        agent1_allowed = false;
        agent1_waiting = false;
        agent1_arrival_time = timeSec;
        fprintf('[%2ds] ○ Агент 1 досяг док-станції.\n', timeSec);
        if agent2_waiting && ~agent2_released
            agent2_release_time = agent1_arrival_time + secondDelay;
        end
    end
    
    % ----------------- AGENT 2 -----------------

    if agent2_allowed && idx2 < nFrames2
        idx2 = min(nFrames2, idx2 + framesPerSec);
    end
    cur2 = pose2(idx2, :);
    dist2 = norm(cur2(1:2) - prevPos2);
    v2 = (dist2 / dt)*k; 
    prevPos2 = cur2(1:2);
    
    if agent2_allowed
        drain2 = batteryDrainPerSec_move(v2)*k;
        battery2 = max(0, battery2 - drain2*dt);
    elseif agent2_waiting
        battery2 = max(0, battery2 - idle_rate*dt);
    else
        battery2 = max(0, battery2 - stop_rate*dt);
    end
    
    set(hTrail2, 'XData', pose2(1:idx2,1), 'YData', pose2(1:idx2,2));
    set(hText2, 'Position', [cur2(1)+0.3, cur2(2)], 'String', sprintf('A2 %.0f%%', battery2));
    theta2 = cur2(3);
    Rz2 = [cos(theta2) -sin(theta2) 0; sin(theta2) cos(theta2) 0; 0 0 1];
    newV2 = (Rz2 * (V)')' + repmat([cur2(1) cur2(2) 0], size(V,1), 1);
    set(agent2_patch, 'Vertices', newV2);
    
    if ~agent2_in_zone && norm(cur2(1:2) - goalLoc) <= zoneHalf
        agent2_in_zone = true;
        agent2_waiting = true;
        agent2_allowed = false;
        agent2_zone_time = timeSec;
        fprintf('[%2ds] ○ Агент 2 увійшов у зону. запит на координацію надіслано.\n', timeSec);
    end
    if idx2 >= nFrames2 && ~agent2_done
        agent2_done = true;
        agent2_allowed = false;
        agent2_waiting = false;
        agent2_arrival_time = timeSec;
        fprintf('[%2ds] ○ Агент 2 досяг док-станції.\n', timeSec);
        if agent1_waiting && ~agent1_released
            agent1_release_time = agent2_arrival_time + secondDelay;
        end
    end
    
    % ----------------- LOGІКА ЦЕНТРА -----------------
% прапорці для логів центру
centerWaitingLogged = false;  % чи вже виведено "центр очікує"
centerDecisionMade = false;   % чи вже прийнято рішення

    % неблокуюча логіка (як у тебе)
if agent1_waiting && ~agent2_waiting && ~agent1_released
    if timeSec - agent1_zone_time >= decisionWindow
        agent1_allowed = true; agent1_waiting = false; agent1_released = true;
        fprintf('[%2ds] ○ Центр приймає рішення: Агент 1 продовжує рух\n', timeSec);
    end
end

if agent2_waiting && ~agent1_waiting && ~agent2_released
    if timeSec - agent2_zone_time >= decisionWindow
        agent2_allowed = true; agent2_waiting = false; agent2_released = true;
        fprintf('[%2ds] ○ Центр приймає рішення: Агент 2 продовжує рух\n', timeSec);
    end
end

if agent1_waiting && agent2_waiting && ~(agent1_released || agent2_released)
    fprintf('[%2ds] ○ Центр очікує ще запити...\n', timeSec);
    if (timeSec - min(agent1_zone_time, agent2_zone_time) >= decisionWindow) || ...
            abs(agent1_zone_time - agent2_zone_time) <= decisionWindow
        if battery1 < battery2
            agent1_allowed = true; agent1_waiting = false; agent1_released = true;
            fprintf('[%2ds] ○ Центр приймає рішення: Агент 1 продовжує рух\n', timeSec);
        else
            agent2_allowed = true; agent2_waiting = false; agent2_released = true;
            fprintf('[%2ds] ○ Центр приймає рішення: Агент 2 продовжує рух\n', timeSec);
        end
    end
end

% Для затриманого релізу (secondDelay)
if ~agent2_allowed && isfinite(agent2_release_time) && timeSec >= agent2_release_time && ~agent2_released
    agent2_allowed = true; agent2_waiting = false; agent2_released = true;
    fprintf('[%2ds] ○ Центр приймає рішення: Агент 2 продовжує рух\n', timeSec);
end
if ~agent1_allowed && isfinite(agent1_release_time) && timeSec >= agent1_release_time && ~agent1_released
    agent1_allowed = true; agent1_waiting = false; agent1_released = true;
    fprintf('[%2ds] ○ Центр приймає рішення: Агент 1 продовжує рух\n', timeSec);
end

    
    % ----------------- ЗАПИС ІСТОРІЇ -----------------
    if timeSec <= maxSimTime
        battery1Array(timeSec) = battery1;
        battery2Array(timeSec) = battery2;
        timeArray(timeSec) = timeSec;
        speed1Array(timeSec) = v1;
        speed2Array(timeSec) = v2;
    end
    
    drawnow limitrate
    pause(0.1)
end

%% --- ПІДСУМОК І ГРАФІКИ ---
valid = ~isnan(timeArray);
tvec = timeArray(valid);
b1 = battery1Array(valid);
b2 = battery2Array(valid);

figure('Name','Battery vs Time');
plot(tvec, b1, '-b','LineWidth',1.6); hold on;
plot(tvec, b2, '-r','LineWidth',1.6);
xlabel('Час, сек'); ylabel('');
legend('Агент 1','Агент 2','Location','southwest'); grid on;
% --- Отримуємо межі графіка ---
ax = gca;
fig = gcf;
xLimits = xlim;
yLimits = ylim;
% Залишаємо осі видимими
set(ax, 'XColor', 'k', 'YColor', 'k'); % чорні осі

% Прибираємо стандартні підписи осей
xlabel(''); 
ylabel('');


% --- Відступ для осей від країв графіка ---
xOffset = 0;  % для Y-осі
yOffset = 0;  % для X-осі

% --- Стрілка осі X ---
[x1_fig, y1_fig] = ds2nfu(ax, xLimits(1)+0.1, yLimits(1)-yOffset);
[x2_fig, y2_fig] = ds2nfu(ax, xLimits(2)+6.5, yLimits(1)-yOffset);
annotation(fig,'arrow', [x1_fig x2_fig], [y1_fig y2_fig], 'LineWidth', 1.5);

% --- Стрілка осі Y ---
[x3_fig, y3_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(1)+0.1);
[x4_fig, y4_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(2)+4);
annotation(fig,'arrow', [x3_fig x4_fig], [y3_fig y4_fig], 'LineWidth', 1.5);

% --- Підпис осі X (трохи правіше) ---
text(mean([xLimits(1) xLimits(2)]) + 95, yLimits(1)-yOffset-2, 't, с', ...
    'FontSize', 14, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top');

% --- Підпис осі Y (вище) ---
text(xLimits(1)-xOffset+8, yLimits(2) + 2, 'Заряд, %', ...
    'FontSize', 14, 'HorizontalAlignment', 'right', 'VerticalAlignment', 'bottom', ...
    'Rotation', 0);

% Додаткові графіки (швидкість)
figure('Name','Speed vs Time');
plot(tvec, speed1Array(valid)*10,'--b','LineWidth',1.4); hold on;
plot(tvec, speed2Array(valid)*10,'--r','LineWidth',1.4);
xlabel('Час, сек'); ylabel('Швидкість, од.'); legend('Агент 1','Агент 2'); grid on;
% --- Отримуємо межі графіка ---
ax = gca;
fig = gcf;
xLimits = xlim;
yLimits = ylim;
% Залишаємо осі видимими
set(ax, 'XColor', 'k', 'YColor', 'k'); % чорні осі

% Прибираємо стандартні підписи осей
xlabel(''); 
ylabel('');


% --- Відступ для осей від країв графіка ---
xOffset = 0;  % для Y-осі
yOffset = 0;  % для X-осі

% --- Стрілка осі X ---
[x1_fig, y1_fig] = ds2nfu(ax, xLimits(1), yLimits(1)-yOffset);
[x2_fig, y2_fig] = ds2nfu(ax, xLimits(2)+12, yLimits(1)-yOffset);
annotation(fig,'arrow', [x1_fig x2_fig], [y1_fig y2_fig], 'LineWidth', 1.5);

% --- Стрілка осі Y ---
[x3_fig, y3_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(1));
[x4_fig, y4_fig] = ds2nfu(ax, xLimits(1)-xOffset, yLimits(2)+0.1);
annotation(fig,'arrow', [x3_fig x4_fig], [y3_fig y4_fig], 'LineWidth', 1.5);

% --- Підпис осі X (трохи правіше) ---
text(mean([xLimits(1) xLimits(2)])+96, yLimits(1)-yOffset, 't,с', ...
    'FontSize', 14, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top');

% --- Підпис осі Y (вище) ---
text(xLimits(1)-xOffset+28, yLimits(2)+0.05, 'Швидкість, м/с', ...
    'FontSize', 14, 'HorizontalAlignment', 'right', 'VerticalAlignment', 'bottom', ...
    'Rotation', 0);

fprintf('\n ПІДСУМОК:\n');
fprintf('Агент 1: %.1f%% заряду залишилось\n', battery1);
fprintf('Агент 2: %.1f%% заряду залишилось\n', battery2);

uiwait(gcf);




